"""
Exploitation Tools

Provides exploitation capabilities for authorized penetration testing.
ALL OPERATIONS IN THIS MODULE REQUIRE EXPLICIT AUTHORIZATION.
"""

import subprocess
import os
from typing import Dict, Any, List, Optional

from ..security import OperationType, get_security_manager, Authorizer


class ExploitTools:
    """Exploitation tools for authorized penetration testing"""

    def __init__(self):
        self.security = get_security_manager()
        self.operation_type = OperationType.EXPLOIT
        self.authorizer = Authorizer(self.security)

    def searchsploit_search(self, query: str) -> Dict[str, Any]:
        """
        Search exploit-db for exploits

        Args:
            query: Search term (software name, version, CVE, etc.)

        Returns:
            Dictionary with search results
        """
        try:
            cmd = ["searchsploit", query, "-w"]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            output = result.stdout

            # Parse results
            exploits = []
            for line in output.split('\n'):
                if line.strip() and '|' in line:
                    parts = [p.strip() for p in line.split('|')]
                    if len(parts) >= 3:
                        try:
                            # Format: Title | Path | Date
                            exploits.append({
                                "title": parts[0],
                                "path": parts[1],
                                "date": parts[2] if len(parts) > 2 else "Unknown"
                            })
                        except ValueError:
                            continue

            self.security.log_operation(
                self.operation_type, "searchsploit", None,
                {"query": query}, f"success - {len(exploits)} results"
            )

            return {
                "success": True,
                "query": query,
                "exploits": exploits[:30],  # Limit results
                "total_found": len(exploits)
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "searchsploit not found. Install with: sudo apt install exploitdb"
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def msfconsole_interact(self, commands: List[str]) -> Dict[str, Any]:
        """
        Interact with Metasploit Framework console

        Args:
            commands: List of msfconsole commands

        Returns:
            Dictionary with execution results
        """
        # This is for information gathering only - actual exploitation
        # requires separate authorization through msf_exploit

        try:
            # Create a temporary resource script
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                for cmd in commands:
                    f.write(cmd + '\n')
                f.write('exit\n')
                script_path = f.name

            try:
                cmd = ["msfconsole", "-r", script_path, "-q"]

                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                output = result.stdout + result.stderr

                self.security.log_operation(
                    self.operation_type, "msfconsole", None,
                    {"commands": commands}, "success"
                )

                return {
                    "success": True,
                    "output": output[:10000],
                    "commands": commands
                }

            finally:
                os.unlink(script_path)

        except FileNotFoundError:
            return {
                "success": False,
                "error": "Metasploit not found. Install with: sudo apt install metasploit-framework"
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Metasploit command timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def hydra_crack(self, target: str, service: str, username: str,
                    wordlist: Optional[str] = None,
                    port: Optional[int] = None) -> Dict[str, Any]:
        """
        Password cracking with Hydra

        WARNING: Requires explicit authorization

        Args:
            target: Target IP or hostname
            service: Service to attack (ssh, ftp, http-post, etc.)
            username: Username to test
            wordlist: Path to password wordlist
            port: Port number (optional)

        Returns:
            Dictionary with cracking results
        """
        # Check authorization requirement
        if self.authorizer.requires_authorization(self.operation_type):
            return {
                "success": False,
                "authorization_required": True,
                "message": self.authorizer.request_authorization(
                    self.operation_type, "hydra", target,
                    {"service": service, "username": username}
                )
            }

        allowed, reason = self.security.validate_operation(self.operation_type, target)
        if not allowed:
            return {"success": False, "error": reason}

        # Default wordlist
        if wordlist is None:
            wordlist = "/usr/share/wordlists/rockyou.txt"

        if not os.path.exists(wordlist):
            return {"success": False, "error": f"Wordlist not found: {wordlist}"}

        try:
            cmd = [
                "hydra",
                "-l", username,
                "-P", wordlist,
                "-t", "4",  # Threads
                "-w", "30",  # Timeout
                "-o", "/tmp/hydra_output.txt",  # Output file
                service,
                target
            ]

            if port:
                cmd.insert(-2, "-s")
                cmd.insert(-2, str(port))

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )

            output = result.stdout

            # Parse results
            success = False
            credentials = []

            if "[ATTEMPT]" in output:
                for line in output.split('\n'):
                    if "[VALID]" in line or "valid password" in line.lower():
                        success = True
                        credentials.append(line.strip())

            self.security.log_operation(
                self.operation_type, "hydra", target,
                {"service": service, "username": username},
                f"complete - success: {success}"
            )

            return {
                "success": True,
                "target": target,
                "service": service,
                "credentials_found": credentials,
                "success": success,
                "raw_output": output[:5000]
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "Hydra not found. Install with: sudo apt install hydra"
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Password cracking timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def john_crack(self, hash_file: str, wordlist: Optional[str] = None,
                   mode: str = "wordlist") -> Dict[str, Any]:
        """
        Password cracking with John the Ripper

        WARNING: Requires explicit authorization

        Args:
            hash_file: Path to file containing hashes
            wordlist: Path to password wordlist
            mode: Cracking mode (wordlist, single, incremental)

        Returns:
            Dictionary with cracking results
        """
        if not os.path.exists(hash_file):
            return {"success": False, "error": f"Hash file not found: {hash_file}"}

        # Default wordlist
        if wordlist is None:
            wordlist = "/usr/share/wordlists/rockyou.txt"

        try:
            cmd = ["john", hash_file]

            if mode == "wordlist" and wordlist:
                cmd.extend(["--wordlist", wordlist])

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )

            # Check for cracked passwords
            show_cmd = ["john", "--show", hash_file]
            show_result = subprocess.run(
                show_cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            cracked = []
            for line in show_result.stdout.split('\n'):
                if ':' in line and not line.startswith(''):
                    cracked.append(line.strip())

            self.security.log_operation(
                self.operation_type, "john_crack", None,
                {"hash_file": hash_file, "mode": mode},
                f"complete - cracked: {len(cracked)}"
            )

            return {
                "success": True,
                "cracked_passwords": cracked,
                "total_cracked": len(cracked),
                "output": result.stdout[:5000]
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "John the Ripper not found. Install with: sudo apt install john"
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def generate_payload(self, payload_type: str, lhost: str, lport: int,
                         format: str = "raw", encoder: Optional[str] = None) -> Dict[str, Any]:
        """
        Generate a payload using msfvenom

        WARNING: For authorized testing only

        Args:
            payload_type: Payload type (e.g., windows/meterpreter/reverse_tcp)
            lhost: Local host for reverse connection
            lport: Local port for reverse connection
            format: Output format (raw, exe, python, bash, etc.)
            encoder: Optional encoder (e.g., x86/shikata_ga_nai)

        Returns:
            Dictionary with payload information
        """
        try:
            cmd = [
                "msfvenom",
                "-p", payload_type,
                f"LHOST={lhost}",
                f"LPORT={lport}",
                "-f", format
            ]

            if encoder:
                cmd.extend(["-e", encoder])

            result = subprocess.run(
                cmd,
                capture_output=True,
                timeout=60
            )

            if result.returncode != 0:
                return {
                    "success": False,
                    "error": result.stderr.decode() if result.stderr else "Payload generation failed"
                }

            payload = result.stdout

            self.security.log_operation(
                self.operation_type, "msfvenom", None,
                {
                    "payload_type": payload_type,
                    "format": format,
                    "lhost": lhost,
                    "lport": lport
                }, "success"
            )

            # Save to file if not raw
            import tempfile
            with tempfile.NamedTemporaryFile(mode='wb', delete=False, suffix=f'.{format}') as f:
                f.write(payload)
                payload_file = f.name

            return {
                "success": True,
                "payload_type": payload_type,
                "format": format,
                "size": len(payload),
                "file": payload_file,
                "lhost": lhost,
                "lport": lport
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "msfvenom not found. Install Metasploit Framework"
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def sqlmap_scan(self, url: str, scan_type: str = "basic",
                    parameters: Optional[List[str]] = None,
                    level: int = 1, risk: int = 1,
                    dbms: Optional[str] = None,
                    batch: bool = True) -> Dict[str, Any]:
        """
        SQL injection testing with sqlmap

        WARNING: Requires explicit authorization

        Args:
            url: Target URL to test for SQL injection
            scan_type: Type of scan (basic, extensive, all_dbs, dump_table)
            parameters: Specific parameters to test (default: all)
            level: Test level (1-5, higher = more tests)
            risk: Risk level (1-3, higher = more risky tests)
            dbms: Force specific DBMS (e.g., MySQL, PostgreSQL, SQL Server)
            batch: Run in non-interactive mode

        Returns:
            Dictionary with scan results
        """
        # Check authorization requirement
        if self.authorizer.requires_authorization(self.operation_type):
            return {
                "success": False,
                "authorization_required": True,
                "message": self.authorizer.request_authorization(
                    self.operation_type, "sqlmap", url,
                    {"scan_type": scan_type, "level": level, "risk": risk}
                )
            }

        allowed, reason = self.security.validate_operation(self.operation_type, url)
        if not allowed:
            return {"success": False, "error": reason}

        try:
            cmd = [
                "sqlmap",
                "-u", url,
                f"--level={level}",
                f"--risk={risk}",
                "--batch" if batch else ""
            ]

            # Remove empty strings
            cmd = [c for c in cmd if c]

            # Add parameters if specified
            if parameters:
                cmd.extend(["-p", ",".join(parameters)])

            # Add DBMS if specified
            if dbms:
                cmd.extend(["--dbms", dbms])

            # Based on scan type, add additional flags
            if scan_type == "extensive":
                cmd.extend(["--techniques", "BEUSTQ"])  # All techniques
            elif scan_type == "all_dbs":
                cmd.append("--dbs")
            elif scan_type == "dump_table":
                cmd.extend(["--dump", "--threads=4"])

            # Add output formatting
            cmd.extend(["--answers=continuing=yes", "--flush-session"])

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600  # 10 minutes
            )

            output = result.stdout + result.stderr

            # Parse key information from output
            is_vulnerable = "sqlmap identified the following injection" in output.lower() or "payload" in output.lower()

            # Extract databases if available
            databases = []
            if "available databases" in output.lower():
                import re
                db_pattern = r'\[\*?\] ([\w_]+)'
                databases = list(set(re.findall(db_pattern, output)))

            self.security.log_operation(
                self.operation_type, "sqlmap", url,
                {
                    "scan_type": scan_type,
                    "level": level,
                    "risk": risk,
                    "vulnerable": is_vulnerable
                },
                f"complete - vulnerable: {is_vulnerable}"
            )

            return {
                "success": True,
                "url": url,
                "scan_type": scan_type,
                "vulnerable": is_vulnerable,
                "databases": databases[:20],  # Limit results
                "output_preview": output[:10000] if len(output) > 10000 else output,
                "command": " ".join(cmd)
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "sqlmap not found. Install with: sudo apt install sqlmap"
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "SQL injection scan timed out after 10 minutes"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def msf_exploit(self, exploit_path: str, options: Dict[str, str],
                    payload: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute a Metasploit exploit module

        WARNING: Requires explicit authorization

        Args:
            exploit_path: Exploit module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
            options: Dictionary of exploit options (RHOSTS, RPORT, LHOST, LPORT, etc.)
            payload: Payload to use (optional)

        Returns:
            Dictionary with exploit results
        """
        # Check authorization requirement
        if self.authorizer.requires_authorization(self.operation_type):
            return {
                "success": False,
                "authorization_required": True,
                "message": self.authorizer.request_authorization(
                    self.operation_type, "msf_exploit", options.get("RHOSTS", "unknown"),
                    {"exploit": exploit_path, "options": options}
                )
            }

        target = options.get("RHOSTS", "unknown")
        allowed, reason = self.security.validate_operation(self.operation_type, target)
        if not allowed:
            return {"success": False, "error": reason}

        try:
            import tempfile

            # Build resource script for msfconsole
            script_lines = []

            # Set exploit module
            script_lines.append(f"use {exploit_path}")

            # Set options
            for key, value in options.items():
                script_lines.append(f"set {key} {value}")

            # Set payload if provided
            if payload:
                script_lines.append(f"set payload {payload}")

            # Set other common options
            if "EnableStageEncoding" not in options:
                script_lines.append("set EnableStageEncoding true")

            # Run exploit
            script_lines.append("exploit -z -j")  # -z for non-interactive, -j for job
            script_lines.append("exit")

            # Create temporary resource script
            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                f.write('\n'.join(script_lines))
                script_path = f.name

            try:
                cmd = ["msfconsole", "-r", script_path, "-q"]

                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=300  # 5 minutes
                )

                output = result.stdout + result.stderr

                # Check if exploit succeeded
                success_indicators = ["session opened", "exploit completed", "meterpreter session"]
                exploit_success = any(indicator in output.lower() for indicator in success_indicators)

                # Extract session info if available
                session_info = []
                if "session" in output.lower():
                    import re
                    session_pattern = r'Session (\d+) opened'
                    sessions = re.findall(session_pattern, output)
                    session_info = sessions

                self.security.log_operation(
                    self.operation_type, "msf_exploit", target,
                    {
                        "exploit": exploit_path,
                        "payload": payload,
                        "success": exploit_success
                    },
                    f"complete - success: {exploit_success}"
                )

                return {
                    "success": True,
                    "exploit": exploit_path,
                    "payload": payload,
                    "exploit_success": exploit_success,
                    "sessions": session_info,
                    "output_preview": output[:10000] if len(output) > 10000 else output,
                    "options": options
                }

            finally:
                os.unlink(script_path)

        except FileNotFoundError:
            return {
                "success": False,
                "error": "Metasploit not found. Install with: sudo apt install metasploit-framework"
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Metasploit exploit timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def msf_auxiliary(self, module_path: str, options: Dict[str, str]) -> Dict[str, Any]:
        """
        Execute a Metasploit auxiliary module

        Args:
            module_path: Auxiliary module path
            options: Dictionary of module options

        Returns:
            Dictionary with execution results
        """
        try:
            import tempfile

            # Build resource script
            script_lines = [
                f"use {module_path}",
            ]

            for key, value in options.items():
                script_lines.append(f"set {key} {value}")

            script_lines.append("run")
            script_lines.append("exit")

            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                f.write('\n'.join(script_lines))
                script_path = f.name

            try:
                cmd = ["msfconsole", "-r", script_path, "-q"]

                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=180
                )

                output = result.stdout + result.stderr

                self.security.log_operation(
                    self.operation_type, "msf_auxiliary", None,
                    {"module": module_path, "options": options}, "success"
                )

                return {
                    "success": True,
                    "module": module_path,
                    "output": output[:10000] if len(output) > 10000 else output,
                    "options": options
                }

            finally:
                os.unlink(script_path)

        except FileNotFoundError:
            return {
                "success": False,
                "error": "Metasploit not found. Install with: sudo apt install metasploit-framework"
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def wpscan_scan(self, url: str, enumerate_type: str = "vp",
                   additional_args: str = "") -> Dict[str, Any]:
        """
        Scan WordPress installations using WPScan

        Args:
            url: Target WordPress URL
            enumerate_type: What to enumerate (vulnerabilities, plugins, themes, vp)
            additional_args: Additional WPScan arguments

        Returns:
            Dictionary with scan results
        """
        allowed, reason = self.security.validate_operation(self.operation_type, url)
        if not allowed:
            return {"success": False, "error": reason}

        try:
            cmd = [
                "wpscan",
                "--url", url,
                "--no-update",  # Don't update the database
                f"--enumerate {enumerate_type}"
            ]

            if additional_args:
                cmd.append(additional_args)

            result = subprocess.run(
                " ".join(cmd),
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )

            output = result.stdout + result.stderr

            # Parse vulnerabilities
            vulnerabilities = []
            if "vulnerabilities" in output.lower():
                import re
                vuln_pattern = r'(\w+)\s*\|\s*([^|]+)\s*\|\s*(\w+)'
                for match in re.finditer(vuln_pattern, output):
                    vuln = {
                        "type": match.group(1),
                        "name": match.group(2).strip(),
                        "severity": match.group(3)
                    }
                    vulnerabilities.append(vuln)

            self.security.log_operation(
                self.operation_type, "wpscan", url,
                {"enumerate_type": enumerate_type},
                f"success - {len(vulnerabilities)} findings"
            )

            return {
                "success": True,
                "target": url,
                "enumerate_type": enumerate_type,
                "vulnerabilities": vulnerabilities[:20],
                "output_preview": output[:10000] if len(output) > 10000 else output
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "WPScan not found. Install with: sudo apt install wpscan"
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "WPScan timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def enum4linux_scan(self, target: str, enumerate_all: bool = True) -> Dict[str, Any]:
        """
        Enumerate information from Windows/Samba servers using enum4linux

        Args:
            target: Target IP or hostname
            enumerate_all: Run all enumeration options (-a flag)

        Returns:
            Dictionary with enumeration results
        """
        allowed, reason = self.security.validate_operation(self.operation_type, target)
        if not allowed:
            return {"success": False, "error": reason}

        try:
            cmd = ["enum4linux"]

            if enumerate_all:
                cmd.append("-a")  # All enumeration options
            else:
                cmd.append("-a")  # Basic enumeration

            cmd.append(target)

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=180
            )

            output = result.stdout

            # Parse key findings
            findings = {
                "shares": [],
                "users": [],
                "groups": [],
                "os_info": ""
            }

            # Extract shares
            if "Share" in output or "smb" in output.lower():
                import re
                share_pattern = r'([\w\$]+)\s*.*?Share'
                shares = re.findall(share_pattern, output)
                findings["shares"] = shares[:10]

            # Extract users
            if "user" in output.lower():
                user_pattern = r'\[\+?Users?\][\s:\[]+([^\]]+)'
                users = re.findall(user_pattern, output)
                findings["users"] = users[:20]

            # Extract groups
            if "group" in output.lower():
                group_pattern = r'\[\+?Groups?\][\s:\[]+([^\]]+)'
                groups = re.findall(group_pattern, output)
                findings["groups"] = groups[:20]

            self.security.log_operation(
                self.operation_type, "enum4linux", target,
                {"enumerate_all": enumerate_all},
                "success"
            )

            return {
                "success": True,
                "target": target,
                "findings": findings,
                "output_preview": output[:10000] if len(output) > 10000 else output
            }

        except FileNotFoundError:
            return {
                "success": False,
                "error": "enum4linux not found. Install with: sudo apt install enum4linux"
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "enum4linux timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}
